import fs =  require('fs');
import path = require('path');
import mkdirp = require('mkdirp');
import chalk = require('chalk');
import SteamCommunity = require('steamcommunity');
import SteamTotp = require('steam-totp');

import TradeOfferManager = require('steam-tradeoffer-manager');
import { appItemsProvider } from '../services/app-items.provider';
import { IBotCredentials } from './bot-configuration.interface';
import { IBotConfig } from './bot-configuration.interface';
import { IBotLoginOptions, IBotPendingtOffer } from './bot.interfaces';

const offerMessage: string = `This trade was generated by CSTRADE.com . \n Please check the correctness of the trade before accepting it.`;

class OfferAsset {
    constructor(assetId: string) {
        this.assetid = assetId;
        this.amout = 1;
        this.contextid = 2;
        this.appid = 730;
    }

    public assetid: string;
    public appid: number;
    public contextid: number;
    public amout: number;
}

export class Bot {

    pendingOffers: Map<string, IBotPendingtOffer> = new Map<string, IBotPendingtOffer>();

    handleOffer(tradeUrl: string, userOffer: string[], appOffer: string[]): Promise<string> {
        return new Promise<string>((resolve, reject) => {

            let theirItems: any[] = userOffer.map(itemId => new OfferAsset(itemId));
            let myItems: any[] = appOffer.map(itemId => new OfferAsset(itemId));

            let offer = this.tradeOfferManager.createOffer(tradeUrl);
            offer.setMessage(offerMessage);

            offer.addMyItems(myItems);
            offer.addTheirItems(theirItems);

            let self = this;

            offer.send((err, status) => {
                if (err) {
                    return reject(err);
                }

                self.pendingOffers.set(offer.id, {
                    offer: offer,
                    resolve: resolve,
                    reject: reject
                });
                
                if (offer.itemsToGive.length === 0) {
                    console.log(`offer ${offer.id} is glitched`);

                    offer.update(() => {
                        let pendingOffer: IBotPendingtOffer = self.pendingOffers.get(offer.id);

                        if (!err) {
                            console.log(`offer ${offer.id} fixed`);
                            pendingOffer.resolve(offer.id);
                        }
                        else {
                            console.log(`offer ${offer.id} not fixed`);
                            pendingOffer.reject(err);
                        }

                        self.pendingOffers.delete(offer.id);
                    });
                }

                //setTimeout(() => {
                //    if (offer.isGlitched()) {
                //
                //
                //    }
                //}, 500);

                this.community.checkConfirmations();
            });
        });
    }

    constructor(private credentials: IBotCredentials,
                private botConfig: IBotConfig) {
        this.init();
    }

    private community: any;
    private tradeOfferManager: any;
    private workingDirectoryPath: string;

    private init(): void {
        this.initWorkingDirectory();
        this.initTradeOfferManager();
        this.initCommunity();
    }

    private initWorkingDirectory(): void {
        this.workingDirectoryPath = path.join(this.botConfig.workspace, this.credentials.accountName);
        mkdirp(this.workingDirectoryPath, null);
    }

    private initCommunity(): void {
        this.community = new SteamCommunity();
        this.login();
        this.setupConfirmations();
    }

    private initTradeOfferManager(): void {
        this.tradeOfferManager = new TradeOfferManager(this.botConfig.tradeOfferManager);
        this.setupPollData();
        this.configureTradeOffers();
    }

    private configureTradeOffers(): void {
        this.tradeOfferManager.on('sentOfferChanged', (offer, oldState) => {
            if (offer.state === TradeOfferManager['ETradeOfferState'].Accepted) {
                appItemsProvider.remove(offer.itemsToGive);
                appItemsProvider.add(offer.itemsToReceive, this.credentials.steamID);
            }
            this.pendingOffers.delete(offer.id);
        });
    }

    private setupConfirmations(): void {
        this.community.on('newConfirmation', confirmation => {
            let time: number = Math.floor(Date.now() / 1000);
            let key: string = SteamTotp.getConfirmationKey(this.credentials.identity_secret, time, "allow");
            let offerID: number = confirmation.offerID;

            let self = this;

            confirmation.respond(time, key, true, err => {
                let offerResponds = self.pendingOffers.get(offerID + '');

                if (!offerResponds) {
                    return;
                }

                if (err) {
                    offerResponds.reject(err.message);
                }
                else {
                    offerResponds.resolve(offerID);
                }
            });
        });

        this.community.on('confKeyNeeded', (tag, callback) => {
            var time: number = Math.floor(Date.now() / 1000);
            let key: string = SteamTotp.getConfirmationKey(this.credentials.identity_secret, time, tag);

            callback(null, time, key);
        });
    }

    private login(): void {
        this.community.login(this.getLoginOptions(), (err, sessionID, cookies, steamguard) => {

                if (err) {
                    chalk.bgRed(err.message);
                    return this.login();
                }

                this.writeDataIntoFile('steamguard.txt', steamguard);

                this.community.chatLogon();

                this.tradeOfferManager.setCookies(cookies, err => {
                    if (err) {
                        throw new Error(err);
                    }
                });

                this.community.startConfirmationChecker(this.botConfig.community.confirmationCheckingInterval);
            }
        );
    }

    private getLoginOptions(): IBotLoginOptions {
        let loginOptions: IBotLoginOptions = {
            accountName: this.credentials.accountName,
            password: this.credentials.password,
            twoFactorCode: SteamTotp.generateAuthCode(this.credentials.shared_secret)
        };

        if (fs.existsSync(`${this.workingDirectoryPath}/steamguard.txt`)) {
            loginOptions.steamguard = fs.readFileSync(`${this.workingDirectoryPath}/steamguard.txt`).toString('utf8');
        }

        return loginOptions;
    }

    private writeDataIntoFile(fileName: string, file: any): void {
        let filePath: string = path.join(this.workingDirectoryPath, fileName);
        fs.writeFile(filePath, file);
    }


    private setupPollData(): void {
        if (fs.existsSync(`${this.workingDirectoryPath}/polldata.json`)) {
            try {
                this.tradeOfferManager.pollData = require(`${this.workingDirectoryPath}/polldata.json`);
            }
            catch (e) {}
        }

        this.tradeOfferManager.on('pollData', pollData => {
            this.writeDataIntoFile('polldata.json', JSON.stringify(pollData));
        });
    }
}